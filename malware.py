# TIme complexity - O(n^2)
# Space COmplexity - O(n)

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:

        def dfs(i, cl, colors):
            if colors[i] != -1:
                return

            colors[i] = cl
            for j in range(n):
                if graph[i][j]:
                    dfs(j, cl, colors)
    
        # no of 
        n = len(graph)
        colors = [-1]* n
        cl = 0
        for i in range(n):
            if colors[i] == -1:
                # assign color
                count = dfs(i,cl, colors)
            cl += 1
        # total elements in each group
        groups = [0] * cl
        for i in range(n):
            c = colors[i] 
            groups[c] += 1

        initGroup = [0] * cl
        for node in initial:
            c = colors[node] 
            initGroup[c] += 1

        re = sys.maxsize
        for node in initial:
            c = colors[node] 
            # if initgroups how many are infected
            cnt = initGroup[c]
            if cnt == 1:  #qulaifies the 
                if re == sys.maxsize: # if first node
                    re = node
                elif groups[c] > groups[colors[re]]: # if saved nodes are more
                    re = node
                elif groups[c] == groups[colors[re]] and node < re:
                    re = node

        if re == sys.maxsize:
            re = min(initial)
        return re

    
